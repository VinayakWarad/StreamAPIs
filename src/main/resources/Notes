1. Difference between Streams and parallelStreams

| Feature                 | `stream()`                                         | `parallelStream()`           |
| ----------------------- | -------------------------------------------------- | ---------------------------- |
| Execution               | Sequential (single thread)                         | Concurrent (multi-threaded)  |
| Order guarantee         | Yes                                                | No (unless `forEachOrdered`) |
| Performance gain        | Only for **large data** & CPU-intensive operations |                              |
| Thread safety required? | Yes, if mutable shared state is accessed           |                              |


2. When NOT to Use Parallel Streams
   For small data sets ‚Äì overhead > benefit.
   When your processing involves I/O or shared mutable state (e.g. writing to a shared list).
   If order of execution is critical and you're using forEach.

| Metric          | `stream()`         | `parallelStream()`                   |
| --------------- | ------------------ | ------------------------------------ |
| Threads used    | 1 (main thread)    | Multiple (ForkJoinPool)              |
| Execution speed | Slower             | Faster (if CPU-bound)                |
| Order guarantee | Yes                | No (unless `forEachOrdered`)         |
| Overhead        | Low                | Higher (splitting + merging threads) |
| Ideal for       | Simple, small data | Large, CPU-heavy operations          |


3. When to Use parallelStream()

   | Situation                 | Recommendation                       |
   | ------------------------- | ------------------------------------ |
   | List size > 10,000 items  | ‚úÖ Consider parallel                  |
   | Heavy CPU task (math ops) | ‚úÖ Yes                                |
   | Light or fast operations  | ‚ùå Avoid parallel                     |
   | Shared mutable state      | ‚ùå Avoid parallel                     |
   | Order-dependent logic     | ‚ùå Use sequential or `forEachOrdered` |

4. Difference between map and reduce

| Feature                   | `map()`                                       | `reduce()`                                                       |
| ------------------------- | --------------------------------------------- | ---------------------------------------------------------------- |
| **Purpose**               | Transforms each element                       | Combines all elements into a single result                       |
| **Input**                 | Function to apply to each element             | Binary operator (2 inputs, 1 output)                             |
| **Output**                | New stream with transformed elements          | Single value (wrapped in `Optional<T>` unless identity provided) |
| **Intermediate/Terminal** | Intermediate operation (can be chained)       | Terminal operation (ends the stream pipeline)                    |
| **Common Use Cases**      | Convert types, extract fields, apply formulas | Sum, max, min, concatenate strings, aggregate values             |
| **Stream Type**           | Returns a **Stream**                          | Returns a **Single value** (e.g. `Optional<T>` or `T`)           |

5. groupingBy :
‚úÖ When to Use groupingBy()
Use Collectors.groupingBy() when you want to group elements in a stream by a specific key or property,
typically to:
Group data (e.g., by department, category, type, etc.)
Aggregate data within each group (count, sum, average, collect into list, etc.)

Format :
Collectors.groupingBy(classifierFunction)
Collectors.groupingBy(classifierFunction, downstreamCollector)

üìå Common Use Cases
1. Count items by a property
Map<String, Long> countByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDept, Collectors.counting()));

2. Group into lists
Map<String, List<Employee>> employeesByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDept));

3. Calculate average by group
Map<String, Double> avgAgeByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDept, Collectors.averagingInt(Employee::getAge)));

4. Sum values by group
Map<String, Integer> totalAgeByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDept, Collectors.summingInt(Employee::getAge)));

5. Nested grouping
Map<String, Map<Integer, List<Employee>>> groupedByDeptThenAge = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDept,
        Collectors.groupingBy(Employee::getAge)));




